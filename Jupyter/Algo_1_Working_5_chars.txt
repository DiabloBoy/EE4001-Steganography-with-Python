from PIL import Image
import cv2
import numpy as np
def encryption_algorithm(msg,n):
    # Where n is the postion of chracter
    secret_msg = str_char(msg)
   
    
    msg_array = ascii_array(secret_msg)
    
    Bin = []
    for i in msg_array:
        Bin.append(bin(i)[2:])
     
    
    
        
    #separates element at position n  
    my_list = [char for char in Bin[n-1]]
    
    #Converts char to int
    
    num_list = []
    for j in range(0,len(my_list)):                           #possible bug
        num_list.append(int(my_list[j]))
        
    
    # Add zero to the front
    i = 0
    
    while len(num_list) < 9:
        num_list.insert(i,0)
        i = i + 1
     
   
    
    matrix = []    
    while num_list != []: 
        matrix.append(num_list[:3])
        num_list = num_list[3:]
    
    
        
    
       
    return matrix

def rotate_90_degree_anticlockwise(matrix):
    new_matrix = []
    for i in range(len(matrix[0]), 0, -1):
        new_matrix.append(list(map(lambda x: x[i-1], matrix)))

    return new_matrix


# Converts String to Characters

def str_char(string):
    l = list(string)
    return l
    
    
#Converts charcters to ASCII values    
def ascii_array(list):
    new_list = []
    bin_list = []
    for i in list:
        new_list.append(int(ord(i)))
    
    return new_list


#This Funtion performs the TMM method shown in Fig 3 of the reading for the password
def BintoTemp(bin_array):
    temp_array = []
    temp_array.append(bin_array[0])
    for i in range(0,len(bin_array)-1):
        temp_array.append(bin_array[i+1] ^ temp_array[i])
    return temp_array


#Key Matrix generator turns list into matrix
def Matrix_Gen(Temp):
    Bin = []
    for i in Temp:
        Bin.append(bin(i)[2:])
        
    #separates last element into a string of characters in binary 
    
    my_list = [char for char in Bin[-1]] #Bug was here

    
   #Converts character to int
    num_list = []
    #print(my_list)
    for j in range(0,len(my_list)):
        num_list.append(int(my_list[j]))
    
    #print(num_list) 
    # Add zero to the front
    i = 0
    
    while len(num_list) < 9:
        num_list.insert(i,0)
        i = i + 1
        
    #print(num_list)  
    
    matrix = [] 
    
    while num_list != []: 
        matrix.append(num_list[:3])
        num_list = num_list[3:] 
  
    return matrix



def encrypt_pixel_mod(msg,position,key_matrix,coords,im):
    
    coords_list = []
    tuple_list =  []
    rotation_list = []
    
    correct_list = []
    first_char_matrix =[]
    
    
    #position is now a list of integers
    #coords is now a list of coords
    # Rotation is a list of integers
   
    matrix_list = char_list_gen(msg,position)
    
    
    
    for i in range(len(msg)):
        
        if (matrix_list[i][0][0] == 0):
            n,correct = checker(matrix_list[i])
        if(matrix_list[i][0][0] == 1):
            first_char_rotated = rotate90Clockwise(matrix_list[i])
            n,correct = checker(first_char_rotated)
            
        rotation_list.append(n)
        correct_list.append(correct)
        
    
    
    for i in range(len(msg)):
        first_char_matrix.append(xor_matrix(correct_list[i],key_matrix))
     
    
    for i in position:
        if (i%3 == 0):
            coords,my_tuple = encryption_1_mod(im,first_char_matrix[i-1],coords,rotation_list[i-1],i-1)
            #print("E1")
        if (i%3 == 1):
            coords,my_tuple = encryption_2_mod(im,first_char_matrix[i-1],coords,rotation_list[i-1],i-1)
            #print("E2")
        if (i%3 == 2):
            coords,my_tuple = encryption_3_mod(im,first_char_matrix[i-1],coords,rotation_list[i-1],i-1)
            #print("E3")
        
        
        tuple_list.append(my_tuple)
        
   
        
    for i in range(len(msg)):
        im.putpixel(coords[i],tuple_list[i])
    
    print("Completed!")
   
    return im                                  

def char_list_gen(msg,position):
    char_matrix_list = []
    for i in position:
          char_matrix_list.append(encryption_algorithm(msg,i))
    
    return char_matrix_list
        


def encryption_1_mod(im,char_n,coords,rotation,i):
    value  = im.getpixel(coords[i])
    
    
    RED =  list(bin(value[0]))
    GREEN = list(bin(value[1]))
    BLUE = list(bin(value[2])) # rotation is encoded here
    
    R = list(bin(rotation))
    
    # Removes "0b"
    R_NEW = R[2:]
    
    #convert rotation number to integer string
    for i in range(0, len(R_NEW)): 
        R_NEW[i] = int(R_NEW[i])
    
    # Creates s 2-bit integer string
    i = 0
    while len(R_NEW) < 2:
        R_NEW.insert(i,0)
        i = i + 1
        
   
    #removes "Ob"
    RED_1 = RED[2:]
    GREEN_1 = GREEN[2:]
    BLUE_1 = BLUE[2:]
    
    new_red = []
    new_green = []
    new_blue = []
    
    for i in RED_1:
        new_red.append(int(i))
    for i in GREEN_1:
        new_green.append(int(i))
    for i in BLUE_1:
         new_blue.append(int(i))
        
        
    eight_bit_red  = list_appender(new_red)
    eight_bit_green = list_appender(new_green)
    eight_bit_blue = list_appender(new_blue)
    
    red_unchanged = eight_bit_red[:4]
    green_unchanged = eight_bit_green[:4]
    blue_unchanged = eight_bit_blue[:-2]
   

    RED_NEW = red_unchanged + char_n[:4]
    GREEN_NEW = green_unchanged + char_n[4:]
    BLUE_NEW = blue_unchanged + R_NEW
    
    
    #convert string to integer
    PUT_RED = str_convert(RED_NEW)
    PUT_GREEN = str_convert(GREEN_NEW)
    PUT_BLUE = str_convert(BLUE_NEW)
   
    
    my_tuple = PUT_RED,PUT_GREEN,PUT_BLUE
    
    return coords,my_tuple

def encryption_2_mod(im,char_n,coords,rotation,i):
    
    value  = im.getpixel(coords[i])
    
    
    RED =  list(bin(value[0]))
    GREEN = list(bin(value[1]))
    BLUE = list(bin(value[2]))
    
    R = list(bin(rotation))
    
     # Removes "0b"
    R_NEW = R[2:]
    
    #convert rotation number to integer string
    for i in range(0, len(R_NEW)): 
        R_NEW[i] = int(R_NEW[i])
    
    # Creates s 2-bit integer string
    i = 0
    while len(R_NEW) < 2:
        R_NEW.insert(i,0)
        i = i + 1
        
    

    
     #removes "Ob"
    GREEN_1 = GREEN[2:]
    BLUE_1 = BLUE[2:]
    RED_1 = RED[2:]
    
    new_red = []
    new_green = []
    new_blue = []
    
    for i in GREEN_1:
        new_green.append(int(i))
    for i in BLUE_1:
        new_blue.append(int(i))
    for i in RED_1:
        new_red.append(int(i))
        
    eight_bit_green  = list_appender(new_green)
    eight_bit_blue = list_appender(new_blue)
    eight_bit_red  = list_appender(new_red)
    
    green_unchanged = eight_bit_green[:4]
    blue_unchanged = eight_bit_blue[:4]
    red_unchanged = eight_bit_red[:-2]

    GREEN_NEW = green_unchanged + char_n[:4]
    BLUE_NEW = blue_unchanged + char_n[4:]
    RED_NEW = red_unchanged + R_NEW
    
    PUT_GREEN = str_convert(GREEN_NEW)
    PUT_BLUE = str_convert(BLUE_NEW)
    PUT_RED = str_convert(RED_NEW)
    
    
    my_tuple = PUT_RED,PUT_GREEN,PUT_BLUE
    
    return coords,my_tuple

def encryption_3_mod(im,char_n,coords,rotation,i):
    
    value  = im.getpixel(coords[i])
    
    RED =  list(bin(value[0])) #Rotation in red pixel
    GREEN =  list(bin(value[1]))
    BLUE = list(bin(value[2]))
    
    R = list(bin(rotation))
    # Removes "0b"
    R_NEW = R[2:]
    
    #convert rotation number to integer string
    for i in range(0, len(R_NEW)): 
        R_NEW[i] = int(R_NEW[i])
    
    # Creates s 2-bit integer string
    i = 0
    while len(R_NEW) < 2:
        R_NEW.insert(i,0)
        i = i + 1
    
     #removes "Ob"
    RED_1 = RED[2:]
    BLUE_1 = BLUE[2:]
    GREEN_1 = GREEN[2:]
    
    
    new_red = []
    new_blue = []
    new_green = []
    
    for i in RED_1:
        new_red.append(int(i))
    for i in BLUE_1:
        new_blue.append(int(i))
    for i in GREEN_1:
        new_green.append(int(i))
        
    eight_bit_red  = list_appender(new_red)
    eight_bit_blue = list_appender(new_blue)
    eight_bit_green = list_appender(new_green)
    
    red_unchanged = eight_bit_red[:4]
    blue_unchanged = eight_bit_blue[:4]
    green_unchanged = eight_bit_green[:-2]

    RED_NEW = red_unchanged + char_n[:4]
    BLUE_NEW = blue_unchanged + char_n[4:]
    GREEN_NEW = green_unchanged + R_NEW
    
    PUT_RED = str_convert(RED_NEW)
    PUT_BLUE = str_convert(BLUE_NEW)
    PUT_GREEN = str_convert(GREEN_NEW)
    
    my_tuple = PUT_RED,PUT_GREEN,PUT_BLUE
    
    
    return coords,my_tuple   



def checker(first_char_rotated):
    
    if(first_char_rotated[0][0] == 0):
        n = 0
        correct = first_char_rotated
        
        
    if(first_char_rotated[0][0] == 1):
        temp = rotate90Clockwise(first_char_rotated)
        n = 1
        
        correct = temp
        
        if(correct[0][0] == 1):
            temp2 = rotate90Clockwise(correct)
            
            n = 2
            correct = temp2
            if (temp2[0][0] == 1):
                print("Cannot be rotated Anymore!")
            
    return n,correct

#This Funtion performs the TMM method shown in Fig 3 of the reading for the password
def BintoTemp(bin_array):
    temp_array = []
    temp_array.append(bin_array[0])
    for i in range(0,len(bin_array)-1):
        temp_array.append(bin_array[i+1] ^ temp_array[i])
    return temp_array


#Key Matrix generator turns list into matrix
def Matrix_Gen(Temp):
    Bin = []
    for i in Temp:
        Bin.append(bin(i)[2:])
        
    #separates last element into a string of characters in binary 
    
    my_list = [char for char in Bin[-1]] #Bug was here

    
   #Converts character to int
    num_list = []
    
    for j in range(0,len(my_list)):
        num_list.append(int(my_list[j]))
    
    
    # Add zero to the front
    i = 0
    
    while len(num_list) < 9:
        num_list.insert(i,0)
        i = i + 1
        
      
    
    matrix = [] 
    
    while num_list != []: 
        matrix.append(num_list[:3])
        num_list = num_list[3:] 
  
    return matrix

def decrypt_pixel_mod(position,key_matrix,coords,im):
    char_list = []
    
    
    for i in position:
        if (i%3 == 0):
            char = decryption_1_mod(im,key_matrix,coords[i-1])
        if (i%3 == 1):
            char = decryption_2_mod(im,key_matrix,coords[i-1])
        if (i%3 == 2):
            char = decryption_3_mod(im,key_matrix,coords[i-1])
            
        char_list.append(char)
        
    print(char_list)
        
    return "Decrypted!"



def decryption_1_mod(stego,key_matrix,coords):
    
    new_value = stego.getpixel(coords)
    
    RED =  list(bin(new_value[0]))
    GREEN = list(bin(new_value[1]))
    BLUE = list(bin(new_value[2]))
    
    RED_1 = RED[2:]
    GREEN_1 = GREEN[2:]
    BLUE_1 = BLUE[2:]
    
    new_red = []
    new_green = []
    new_blue = []
    
    for i in RED_1:
        new_red.append(int(i))
    for i in GREEN_1:
        new_green.append(int(i))
    
            
    r_temp = BLUE_1[-2:]
    
    number_of_rotations = str_convert(r_temp)
     
    eight_bit_red  = list_appender(new_red)
    eight_bit_green = list_appender(new_green)
    
    red_nibble = eight_bit_red[4:]
    green_nibble = eight_bit_green[4:]
    
    new_list = red_nibble + green_nibble
    
    new_list.insert(0,0)
    
    matrix = [] 
    
    while new_list != []: 
        matrix.append(new_list[:3])
        new_list = new_list[3:]
        
    #XOR first   
    
    my_matrix = xor_matrix_decrypt(matrix,key_matrix)
    
    if(number_of_rotations == 0):
        final = my_matrix
        
            
    if(number_of_rotations == 1 ):
        final = rotate_90_degree_anticlockwise(my_matrix)
      
        
    if(number_of_rotations == 2 ):
        temp = rotate_90_degree_anticlockwise(my_matrix)
        temp2 = rotate_90_degree_anticlockwise(temp)
        final =  temp2
        
    if(number_of_rotations == 3 ):
        temp = rotate_90_degree_anticlockwise(my_matrix)
        temp2 = rotate_90_degree_anticlockwise(temp)
        temp3 = rotate_90_degree_anticlockwise(temp2)
        
        final = temp3
    
    decoded_array = []
    
    for i in range(1,3):
        decoded_array.append(final[0][i])
        
    for i in range(0,3):
        decoded_array.append(final[1][i])
        
    for i in range(0,3):
        decoded_array.append(final[2][i])
        
    string_array = []
    
    for i in decoded_array:
        string_array.append(str(i))
        
    binary_string = "".join(string_array)
    letter = int(binary_string,2)
    
    return chr(letter)


def decryption_2_mod(stego,key_matrix,coords):
    
    new_value = stego.getpixel(coords)
    
    
    
    RED =  list(bin(new_value[0]))
    GREEN = list(bin(new_value[1]))
    BLUE = list(bin(new_value[2]))
    
    
    RED_1 = RED[2:]
    GREEN_1 = GREEN[2:]
    BLUE_1 = BLUE[2:]
    
    new_red = []
    new_green = []
    new_blue = []
    
    r_temp = RED_1[-2:]
    
    number_of_rotations = str_convert(r_temp)
    
    
    for i in BLUE_1:
        new_blue.append(int(i))
    for i in GREEN_1:
        new_green.append(int(i))
        
    eight_bit_blue  = list_appender(new_blue)
    eight_bit_green = list_appender(new_green)
    
    blue_nibble = eight_bit_blue[4:]
    green_nibble = eight_bit_green[4:]
    
    new_list =  green_nibble + blue_nibble
    
    new_list.insert(0,0)
    
    matrix = [] 
    while new_list != []: 
        matrix.append(new_list[:3])
        new_list = new_list[3:]
    
    #XOR first
    my_matrix = xor_matrix_decrypt(matrix,key_matrix)
    
    if(number_of_rotations == 0):
        final = my_matrix
        
            
    if(number_of_rotations == 1 ):
       
        final = rotate_90_degree_anticlockwise(my_matrix)
      
        
    if(number_of_rotations == 2 ):
        temp = rotate_90_degree_anticlockwise(my_matrix)
        temp2 = rotate_90_degree_anticlockwise(temp)
        final =  temp2
        
    if(number_of_rotations == 3 ):
        temp = rotate_90_degree_anticlockwise(my_matrix)
        temp2 = rotate_90_degree_anticlockwise(temp)
        temp3 = rotate_90_degree_anticlockwise(temp2)
        
        final = temp3
    
    
    decoded_array = []
    
    for i in range(1,3):
        decoded_array.append(final[0][i])
        
    for i in range(0,3):
        decoded_array.append(final[1][i])
        
    for i in range(0,3):
        decoded_array.append(final[2][i])
        
    string_array = []
    
    for i in decoded_array:
        string_array.append(str(i))
        
    binary_string = "".join(string_array)
    letter = int(binary_string,2)
    
    return chr(letter)

def decryption_3_mod(stego,key_matrix,coords):
    
    new_value = stego.getpixel(coords)
    
   
   
    RED = list(bin(new_value[0]))
    GREEN = list(bin(new_value[1]))
    BLUE = list(bin(new_value[2]))
    
    
   
    RED_1 = RED[2:]
    GREEN_1 = GREEN[2:]
    BLUE_1 = BLUE[2:]
    
   
    new_red = []
    new_blue = []
    new_green = []
    
    for i in RED_1:
        new_red.append(int(i))
    for i in BLUE_1:
        new_blue.append(int(i))
    for i in GREEN_1:
        new_green.append(int(i))
    
    #rotation stored in green
    r_temp = GREEN_1[-2:]
    
    
    number_of_rotations = str_convert(r_temp)
        
    eight_bit_blue  = list_appender(new_blue)
    eight_bit_red = list_appender(new_red)
    
    blue_nibble = eight_bit_blue[4:]
    red_nibble = eight_bit_red[4:]
    
    new_list = red_nibble + blue_nibble
    
    new_list.insert(0,0)
    
    matrix = [] 
    while new_list != []: 
        matrix.append(new_list[:3])
        new_list = new_list[3:]
        
    my_matrix = xor_matrix_decrypt(matrix,key_matrix)
    
    
    
    if(number_of_rotations == 0):
        final = my_matrix
        
            
    if(number_of_rotations == 1 ):
       
        final = rotate_90_degree_anticlockwise(my_matrix)
      
        
    if(number_of_rotations == 2 ):
        temp = rotate_90_degree_anticlockwise(my_matrix)
        temp2 = rotate_90_degree_anticlockwise(temp)
        final =  temp2
        
    if(number_of_rotations == 3 ):
        temp = rotate_90_degree_anticlockwise(my_matrix)
        temp2 = rotate_90_degree_anticlockwise(temp)
        temp3 = rotate_90_degree_anticlockwise(temp2)
        
        final = temp3
   
    
    decoded_array = []
    
    for i in range(1,3):
        decoded_array.append(final[0][i])
        
    for i in range(0,3):
        decoded_array.append(final[1][i])
        
    for i in range(0,3):
        decoded_array.append(final[2][i])
        
    string_array = []
    
    for i in decoded_array:
        string_array.append(str(i))
        
    binary_string = "".join(string_array)
    letter = int(binary_string,2)
    
    return chr(letter)

def xor_matrix_decrypt(B,key_matrix):
    temp_array = []
    for i in range(0,3):
        temp_array.append(B[0][i] ^ key_matrix[0][i])
    for j in range(0,3):
        temp_array.append(B[1][j] ^ key_matrix[1][j])
    for k in range(0,3):
        temp_array.append(B[2][k] ^ key_matrix[2][k])
    matrix = []   
    
    while temp_array != []: 
        matrix.append(temp_array [:3])
        temp_array  = temp_array [3:] 
  
    return matrix

def xor_matrix(B,key_matrix):
    
    temp_array = []
    for i in range(0,3):
        temp_array.append(B[0][i] ^ key_matrix[0][i])
    for j in range(0,3):
        temp_array.append(B[1][j] ^ key_matrix[1][j])
    for k in range(0,3):
        temp_array.append(B[2][k] ^ key_matrix[2][k])
        
    eight_bit_array = temp_array[1:]
    
    #if(temp_array[0] == 1):
        #print("Not Compatible")
  
    return eight_bit_array

def list_appender(num_list):
    i = 0
    while len(num_list) < 8:
        num_list.insert(i,0)
        i = i + 1
    return num_list

#converts a binary string to decimal
def str_convert(list):
    new_list = []
    ans = ""
    value = 0
    for i in list:
        new_list.append(str(i))
    ans = ''.join(new_list)
    value = int(ans,2)
    return value
################################################ Run code below here ####################################################
######### #######################################Password Encryption#####################################################
# Password encryption

test_list = str_char("secret")

bin_array = ascii_array(test_list)

Temp = BintoTemp(bin_array)

key_matrix = Matrix_Gen(Temp)


position = list(range(1,6))

coords = [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0)]

im = Image.open("cover.jpg")

msg = 'hello'

my_list = char_list_gen(msg,position)

stego = encrypt_pixel_mod(msg,position,key_matrix,coords,im)

stego.save("stego_NEWEST.jpg","JPEG")



decrypt_pixel_mod(position,key_matrix,coords,stego)


 
                                 

                                 
         
    
    
    

        
        
        
        
    
 